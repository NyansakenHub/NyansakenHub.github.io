<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Endless Ring Escalation Physics</title>
<style>
html, body {
    margin: 0;
    padding: 0;
    background: #0b0b0b;
    overflow: hidden;
}
canvas {
    display: block;
}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
/*
=====================================================
CANVAS
=====================================================
*/
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/*
=====================================================
MATH UTILITIES
=====================================================
*/
const TAU = Math.PI * 2;

function dot(a,b){ return a.x*b.x + a.y*b.y; }
function len(v){ return Math.hypot(v.x,v.y); }
function norm(v){
    const l = len(v);
    return l === 0 ? {x:0,y:0} : {x:v.x/l,y:v.y/l};
}
function add(a,b){ return {x:a.x+b.x,y:a.y+b.y}; }
function sub(a,b){ return {x:a.x-b.x,y:a.y-b.y}; }
function mul(v,s){ return {x:v.x*s,y:v.y*s}; }

/*
=====================================================
GLOBAL ESCALATION STATE
=====================================================
*/
let cycle = 0;
let gravityBase = 900;
let initialSpeedBase = 500;
let angularSpeed = 0;
let waveAmplitude = 0;
let ringThickness = 18;

function applyCycleEscalation() {
    cycle++;
    gravityBase *= 1.05;
    initialSpeedBase *= 1.04;
    angularSpeed += 0.05;          // radians/sec
    waveAmplitude += 4;            // px
    ringThickness *= 0.95;
}

/*
=====================================================
RINGS
=====================================================
*/
const RING_COUNT = 15;
let rings = [];
let rotation = 0;
let ringFade = 0;

const center = () => ({ x: canvas.width/2, y: canvas.height/2 });

function regenerateRings() {
    rings.length = 0;
    const baseRadius = Math.min(canvas.width, canvas.height) * 0.12;
    const spacing = ringThickness * 2.2;

    for (let i = 0; i < RING_COUNT; i++) {
        rings.push({
            baseRadius: baseRadius + i * spacing,
            alive: true
        });
    }
    ringFade = 1;
}

regenerateRings();

/*
=====================================================
BALL
=====================================================
*/
const ball = {
    pos: center(),
    vel: {x: initialSpeedBase, y: -initialSpeedBase*0.6},
    r: 8
};

function resetBallVelocity() {
    const angle = Math.random() * TAU;
    ball.vel = {
        x: Math.cos(angle) * initialSpeedBase,
        y: Math.sin(angle) * initialSpeedBase
    };
}

/*
=====================================================
PHYSICS
=====================================================
*/
function reflectVelocity(v, normal) {
    // v' = v - 2(vÂ·n)n
    const d = dot(v, normal);
    return sub(v, mul(normal, 2*d));
}

function collideRings(dt, time) {
    let hit = false;
    const c = center();

    for (let i = rings.length - 1; i >= 0; i--) {
        if (!rings[i].alive) continue;

        const wave = Math.sin(time * 2 + i) * waveAmplitude;
        const radius = rings[i].baseRadius + wave;
        const distVec = sub(ball.pos, c);
        const dist = len(distVec);

        if (dist + ball.r > radius - ringThickness/2 &&
            dist - ball.r < radius + ringThickness/2) {

            // Surface normal (accounts for rotation by rotating space)
            const normal = norm(distVec);

            // Position correction
            const penetration = (dist + ball.r) - (radius - ringThickness/2);
            ball.pos = sub(ball.pos, mul(normal, penetration));

            // Reflect velocity
            const speedBefore = len(ball.vel);
            ball.vel = reflectVelocity(ball.vel, normal);

            // Restore speed to counter gravity losses
            const speedAfter = len(ball.vel);
            if (speedAfter !== 0) {
                ball.vel = mul(ball.vel, speedBefore / speedAfter);
            }

            rings[i].alive = false;
            hit = true;
            break;
        }
    }

    if (hit) ringFade = 1;
}

function ensureInside() {
    const c = center();
    const distVec = sub(ball.pos, c);
    const dist = len(distVec);

    if (rings.every(r => !r.alive)) return;

    const inner = rings.find(r => r.alive);
    if (!inner) return;

    const radius = inner.baseRadius - ringThickness/2 - ball.r;
    if (dist > radius) {
        const n = norm(distVec);
        const tangent = { x: -n.y, y: n.x };
        const tangentialSpeed = dot(ball.vel, tangent);

        ball.pos = add(c, mul(n, radius));
        ball.vel = mul(tangent, tangentialSpeed);
    }
}

/*
=====================================================
UPDATE & DRAW
=====================================================
*/
let last = performance.now();

function update(now) {
    const dt = Math.min((now - last) / 1000, 0.033);
    last = now;

    rotation += angularSpeed * dt;

    // Gravity
    ball.vel.y += gravityBase * dt;

    // Integrate
    ball.pos = add(ball.pos, mul(ball.vel, dt));

    // Collisions
    collideRings(dt, now/1000);

    // Remove dead rings
    rings = rings.filter(r => r.alive);

    // Regeneration
    if (rings.length === 0) {
        applyCycleEscalation();
        regenerateRings();
        resetBallVelocity();
    }

    ensureInside();

    ringFade = Math.max(0, ringFade - dt * 2);
}

function draw(now) {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const c = center();

    // Rings
    rings.forEach((r, i) => {
        const wave = Math.sin(now*0.002 + i) * waveAmplitude;
        const radius = r.baseRadius + wave;

        ctx.strokeStyle = `hsla(${(cycle*40+i*10)%360},80%,60%,${0.8+ringFade*0.2})`;
        ctx.lineWidth = ringThickness;
        ctx.beginPath();
        ctx.arc(c.x, c.y, radius, 0, TAU);
        ctx.stroke();
    });

    // Ball
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(ball.pos.x, ball.pos.y, ball.r, 0, TAU);
    ctx.fill();
}

function loop(now) {
    update(now);
    draw(now);
    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
